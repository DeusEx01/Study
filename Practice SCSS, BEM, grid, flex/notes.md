## Вопросы
1. Почему переменные в _variables.scss записываются в нативные переменные css --var а не в scss переменные, которые после компиляции становятся обычными css свойствами, без необходимости для css в их преобразовании, когда это касается нативных переменных css.
Answer: "По переменным — потому что CSS-переменные работают в рантайме, это зачастую удобнее, нежели использовать компилируемые переменные из Sass.

Отвечаю на вопрос. 

Во-первых, не нужно путать :root {} и $ — это о разном. 

:root {} — это обычный CSS-селектор, аналог селектора html {}, дающий доступ к <html>, корневому элементу. В этом селекторе принято объявлять так называемые глобальные переменные, которые будут использоваться в стилях многих компонентов страницы. 

$ — это синтаксис объявления (и по совместительству использования) Sass-переменной. 

В CSS же переменные объявляются через двойной символ '-', а используются через функцию var().

Sass-переменные и CSS-переменные служат разным целям и они совершенно разные, не только в синтаксисе. 

CSS-переменные работают в рантайме (во время обработки стилей браузером), а Sass-переменные после компиляции scss => css пропадают из финального файла, заменяются на конкретные значения. 

CSS-переменными можно манипулировать через JS, а Sass — нет. 

CSS-переменные подверженны всем принципам каскада, а в сочетании с работой в рантайме, можно творить очень классные штуки. 

Приведу пример. Бывают ситуации, когда различным всплывающим менюшкам и модальным окнам нужно знать, какой высоты сейчас шапка страницы. Эта задача решается так: через JS получаем текущую высоту шапки, через JS в :root {} записываем новую глобальную CSS-переменную header-height, в которой будет соответствующее значение, затем эта переменная будет использована в CSS там, где требуется. А при ресайзе окна (изменении ширины в частности) через JS обновляем значение header-height, чтобы стили зависящих от шапки элементов своевременно обновились. 

На Sass-переменных сделать это невозможно. 

И темизация — большая и сложная механика, которую на Sass сделать можно, но так редко кто делает, обычно используются классические CSS-переменные, которые можно переопределять, в зависимости от наличия на <html> или <body> специального класса от темы. 

Вообще, раньше CSS-переменных не было, поэтому все использовали Sass-переменные, сейчас же это не обязательно, лучше использовать нативный инструмент, а не надстройку.

Удобство синтаксиса — вопрос привычки. Когда нужна мощь нативных CSS-переменных (а это требуется почти всегда в реальных проектах), можно и нужно писать переменные через var, иного пути нет.

И последнее: Sass-переменные стоит использовать в Sass-синтакисе, а CSS — в CSS.

О чем это я. 

В параметрах Sass-миксина без $ не обойтись, а в CSS-функции calc() можно смело использовать нативные var() переменные и это будет прекрасно работать.
"

## Свойства
1. margin-inline
2. clamp()
3. html academy 'как прятать' 
  ```css
    position: absolute;
    width: 1px;
    height: 1px;
    margin: -1px;
    border: 0;
    padding: 0;
    white-space: nowrap;
    clip-path: inset(100%);
    clip: rect(0 0 0 0);
    overflow: hidden;
  ```
4. dialog тег для всплывающих элементов (меню)
5. display: contents 60:08 https://www.youtube.com/shorts/CSegskzuGxk?feature=share


## Notes
  1. Для кнопок необходимо добавлять аттрибут type="button" всегда, если они не являются частью формы
  2. Для элементов, которые визуально скрыты или не имеют названия, но имеют функцию. К примеру кнопка бургер меню, которая не имеет текста, мы в целях ДОСТУПНОСТИ для скринридеров добавляем текст, к примеру в `span`внутри которого пишем, что это *Open navigation menu* и добавляем ему класс visually-hidden. Таким образом мы добавляем доступность для элемента.
  3. Для медиазапросов вроде `media(max-width: 768px)` необходимо добавлять сотые единицы e.g. `768.98px` т.к.:
  "Это из-за нестандартной плотности пикселей твоего монитора. Забываю о том, что такой баг может у некоторых возникать. Тебе нужно вместо ровных значений 767 использовать 767.98 в медиазапросах и всё будет работать как надо."
  4. Для изображений указывать аттрибут `loading="lazy"`